## **粒子群算法复现**

:smile::smile::smile:

___

### **PSO算法**

**粒子群算法受启发于鸟群觅食，将每一只鸟抽象成一个微粒。**

**存在一个鸟群，所有的鸟都不知道事物的位置，但它们知道距离食物的位置。**

**所有的粒子都有一个适应度，用于衡量离食物的距离，并且有速度和位置，用于描述当前位置以及位移。**

**粒子追随粒子群中最优粒子在解空间中搜索。**



___

### 决策变量

假设在D维搜索空间中，有m个粒子。

- 其中第i个粒子的位置矢量是：$\vec x=(x_1,x_2,x_3,......,x_i)$
- 其飞翔速度也是矢量：$\vec v=(v_1,v_2,v_3,......,v_i)$
- 第i个粒子搜索到的最优位置是：$\vec p_i=(p_{i1},p_{i2},p_{i3},......,p_{i3})$
- 整个粒子群搜索到的最优位置是：$\vec p_{gbest}=(p_{gbest1},p_{gbest2},p_{gbest3},......,p_{gbesti})$
- 第i个粒子的位置和速度更新为:
  - $v_{id}^{k+1}=wv_{id}^k+c_1rand(0)(p_{id}-x_{id}^k)+c_2rand(0)(p_{gbest}-x_{id}^k)$ 
  - $x_{id}^{k+1}=x_{id}^k+v_{id}^{k+1}$



___

### 算法步骤

1. 使用随机位置和速度初始化粒子群
2. 循环计算每个粒子的位置$x_i$，计算适应度
3. 如果$fitness(x_i)更优于fitness(p)$，then $p=x_i$，跳转至第2步，直至粒子遍历完毕
4. 设置最优位置$ps作为gBest$
5. 更新粒子的速度和位置，跳转至第2步，直至迭代完毕
6. 得出$gBest最优解$



___

**作者水平有限，文档并不能很好地帮助读者理解代码，并且十分简陋，只能大致讲解一下算法本身，敬请谅解。**

:smile::smile::smile:


