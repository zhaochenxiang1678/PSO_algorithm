## **粒子群算法复现**

:smile::smile::smile:

___

### **PSO算法**

**粒子群算法受启发于鸟群觅食，将每一只鸟抽象成一个微粒。**

**存在一个鸟群，所有的鸟都不知道事物的位置，但它们知道距离食物的位置。**

**所有的粒子都有一个适应度，用于衡量离食物的距离，并且有速度和位置，用于描述当前位置以及位移。**

**粒子追随粒子群中最优粒子在解空间中搜索。**



___

### 决策变量

假设在D维搜索空间中，有m个粒子。

- **位置向量**：$\vec{x}_i = (x_{i1}, x_{i2}, \ldots, x_{id})$
- **速度向量**：$\vec{v}_i = (v_{i1}, v_{i2}, \ldots, v_{id})$
- **个体最优**：$\vec{p}_i = (p_{i1}, p_{i2}, \ldots, p_{id})$
- **全局最优**：$\vec{g} = (g_1, g_2, \ldots, g_d)$

### 更新公式

**速度更新**：
$$v_{id}^{t+1} = w \cdot v_{id}^t + c_1 r_1 (p_{id} - x_{id}^t) + c_2 r_2 (g_d - x_{id}^t)$$

**位置更新**：
$$x_{id}^{t+1} = x_{id}^t + v_{id}^{t+1}$$

其中 $r_1, r_2 \sim U(0,1)$ 是随机数。

___

### 算法步骤

1. 使用随机位置和速度初始化粒子群
2. 循环计算每个粒子的位置$x_i$，计算适应度
3. 如果$fitness(x_i)更优于fitness(p)$，then $p=x_i$，跳转至第2步，直至粒子遍历完毕
4. 设置最优位置$ps作为gBest$
5. 更新粒子的速度和位置，跳转至第2步，直至迭代完毕
6. 得出$gBest最优解$



___

**作者水平有限，文档并不能很好地帮助读者理解代码，并且十分简陋，只能大致讲解一下算法本身，敬请谅解。**

:smile::smile::smile:



